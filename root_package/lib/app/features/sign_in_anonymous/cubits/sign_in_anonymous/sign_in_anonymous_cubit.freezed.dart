// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'sign_in_anonymous_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$SignInAnonymousStateTearOff {
  const _$SignInAnonymousStateTearOff();

// ignore: unused_element
  SignInAnonymousInitialized initialized() {
    return const SignInAnonymousInitialized();
  }

// ignore: unused_element
  SignInAnonymousLoadInProgress loadInProgress() {
    return const SignInAnonymousLoadInProgress();
  }

// ignore: unused_element
  SignInAnonymousLoadSuccess loadSuccess(UserEntity userEntity) {
    return SignInAnonymousLoadSuccess(
      userEntity,
    );
  }

// ignore: unused_element
  SignInAnonymousLoadFailure loadFailure(AuthFailure failure) {
    return SignInAnonymousLoadFailure(
      failure,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SignInAnonymousState = _$SignInAnonymousStateTearOff();

/// @nodoc
mixin _$SignInAnonymousState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initialized(),
    @required Result loadInProgress(),
    @required Result loadSuccess(UserEntity userEntity),
    @required Result loadFailure(AuthFailure failure),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initialized(),
    Result loadInProgress(),
    Result loadSuccess(UserEntity userEntity),
    Result loadFailure(AuthFailure failure),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initialized(SignInAnonymousInitialized value),
    @required Result loadInProgress(SignInAnonymousLoadInProgress value),
    @required Result loadSuccess(SignInAnonymousLoadSuccess value),
    @required Result loadFailure(SignInAnonymousLoadFailure value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initialized(SignInAnonymousInitialized value),
    Result loadInProgress(SignInAnonymousLoadInProgress value),
    Result loadSuccess(SignInAnonymousLoadSuccess value),
    Result loadFailure(SignInAnonymousLoadFailure value),
    @required Result orElse(),
  });
}

/// @nodoc
abstract class $SignInAnonymousStateCopyWith<$Res> {
  factory $SignInAnonymousStateCopyWith(SignInAnonymousState value,
          $Res Function(SignInAnonymousState) then) =
      _$SignInAnonymousStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignInAnonymousStateCopyWithImpl<$Res>
    implements $SignInAnonymousStateCopyWith<$Res> {
  _$SignInAnonymousStateCopyWithImpl(this._value, this._then);

  final SignInAnonymousState _value;
  // ignore: unused_field
  final $Res Function(SignInAnonymousState) _then;
}

/// @nodoc
abstract class $SignInAnonymousInitializedCopyWith<$Res> {
  factory $SignInAnonymousInitializedCopyWith(SignInAnonymousInitialized value,
          $Res Function(SignInAnonymousInitialized) then) =
      _$SignInAnonymousInitializedCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignInAnonymousInitializedCopyWithImpl<$Res>
    extends _$SignInAnonymousStateCopyWithImpl<$Res>
    implements $SignInAnonymousInitializedCopyWith<$Res> {
  _$SignInAnonymousInitializedCopyWithImpl(SignInAnonymousInitialized _value,
      $Res Function(SignInAnonymousInitialized) _then)
      : super(_value, (v) => _then(v as SignInAnonymousInitialized));

  @override
  SignInAnonymousInitialized get _value =>
      super._value as SignInAnonymousInitialized;
}

/// @nodoc
class _$SignInAnonymousInitialized implements SignInAnonymousInitialized {
  const _$SignInAnonymousInitialized();

  @override
  String toString() {
    return 'SignInAnonymousState.initialized()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SignInAnonymousInitialized);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initialized(),
    @required Result loadInProgress(),
    @required Result loadSuccess(UserEntity userEntity),
    @required Result loadFailure(AuthFailure failure),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initialized();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initialized(),
    Result loadInProgress(),
    Result loadSuccess(UserEntity userEntity),
    Result loadFailure(AuthFailure failure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initialized != null) {
      return initialized();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initialized(SignInAnonymousInitialized value),
    @required Result loadInProgress(SignInAnonymousLoadInProgress value),
    @required Result loadSuccess(SignInAnonymousLoadSuccess value),
    @required Result loadFailure(SignInAnonymousLoadFailure value),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return initialized(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initialized(SignInAnonymousInitialized value),
    Result loadInProgress(SignInAnonymousLoadInProgress value),
    Result loadSuccess(SignInAnonymousLoadSuccess value),
    Result loadFailure(SignInAnonymousLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (initialized != null) {
      return initialized(this);
    }
    return orElse();
  }
}

abstract class SignInAnonymousInitialized implements SignInAnonymousState {
  const factory SignInAnonymousInitialized() = _$SignInAnonymousInitialized;
}

/// @nodoc
abstract class $SignInAnonymousLoadInProgressCopyWith<$Res> {
  factory $SignInAnonymousLoadInProgressCopyWith(
          SignInAnonymousLoadInProgress value,
          $Res Function(SignInAnonymousLoadInProgress) then) =
      _$SignInAnonymousLoadInProgressCopyWithImpl<$Res>;
}

/// @nodoc
class _$SignInAnonymousLoadInProgressCopyWithImpl<$Res>
    extends _$SignInAnonymousStateCopyWithImpl<$Res>
    implements $SignInAnonymousLoadInProgressCopyWith<$Res> {
  _$SignInAnonymousLoadInProgressCopyWithImpl(
      SignInAnonymousLoadInProgress _value,
      $Res Function(SignInAnonymousLoadInProgress) _then)
      : super(_value, (v) => _then(v as SignInAnonymousLoadInProgress));

  @override
  SignInAnonymousLoadInProgress get _value =>
      super._value as SignInAnonymousLoadInProgress;
}

/// @nodoc
class _$SignInAnonymousLoadInProgress implements SignInAnonymousLoadInProgress {
  const _$SignInAnonymousLoadInProgress();

  @override
  String toString() {
    return 'SignInAnonymousState.loadInProgress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is SignInAnonymousLoadInProgress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initialized(),
    @required Result loadInProgress(),
    @required Result loadSuccess(UserEntity userEntity),
    @required Result loadFailure(AuthFailure failure),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initialized(),
    Result loadInProgress(),
    Result loadSuccess(UserEntity userEntity),
    Result loadFailure(AuthFailure failure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initialized(SignInAnonymousInitialized value),
    @required Result loadInProgress(SignInAnonymousLoadInProgress value),
    @required Result loadSuccess(SignInAnonymousLoadSuccess value),
    @required Result loadFailure(SignInAnonymousLoadFailure value),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadInProgress(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initialized(SignInAnonymousInitialized value),
    Result loadInProgress(SignInAnonymousLoadInProgress value),
    Result loadSuccess(SignInAnonymousLoadSuccess value),
    Result loadFailure(SignInAnonymousLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadInProgress != null) {
      return loadInProgress(this);
    }
    return orElse();
  }
}

abstract class SignInAnonymousLoadInProgress implements SignInAnonymousState {
  const factory SignInAnonymousLoadInProgress() =
      _$SignInAnonymousLoadInProgress;
}

/// @nodoc
abstract class $SignInAnonymousLoadSuccessCopyWith<$Res> {
  factory $SignInAnonymousLoadSuccessCopyWith(SignInAnonymousLoadSuccess value,
          $Res Function(SignInAnonymousLoadSuccess) then) =
      _$SignInAnonymousLoadSuccessCopyWithImpl<$Res>;
  $Res call({UserEntity userEntity});
}

/// @nodoc
class _$SignInAnonymousLoadSuccessCopyWithImpl<$Res>
    extends _$SignInAnonymousStateCopyWithImpl<$Res>
    implements $SignInAnonymousLoadSuccessCopyWith<$Res> {
  _$SignInAnonymousLoadSuccessCopyWithImpl(SignInAnonymousLoadSuccess _value,
      $Res Function(SignInAnonymousLoadSuccess) _then)
      : super(_value, (v) => _then(v as SignInAnonymousLoadSuccess));

  @override
  SignInAnonymousLoadSuccess get _value =>
      super._value as SignInAnonymousLoadSuccess;

  @override
  $Res call({
    Object userEntity = freezed,
  }) {
    return _then(SignInAnonymousLoadSuccess(
      userEntity == freezed ? _value.userEntity : userEntity as UserEntity,
    ));
  }
}

/// @nodoc
class _$SignInAnonymousLoadSuccess implements SignInAnonymousLoadSuccess {
  const _$SignInAnonymousLoadSuccess(this.userEntity)
      : assert(userEntity != null);

  @override
  final UserEntity userEntity;

  @override
  String toString() {
    return 'SignInAnonymousState.loadSuccess(userEntity: $userEntity)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignInAnonymousLoadSuccess &&
            (identical(other.userEntity, userEntity) ||
                const DeepCollectionEquality()
                    .equals(other.userEntity, userEntity)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(userEntity);

  @override
  $SignInAnonymousLoadSuccessCopyWith<SignInAnonymousLoadSuccess>
      get copyWith =>
          _$SignInAnonymousLoadSuccessCopyWithImpl<SignInAnonymousLoadSuccess>(
              this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initialized(),
    @required Result loadInProgress(),
    @required Result loadSuccess(UserEntity userEntity),
    @required Result loadFailure(AuthFailure failure),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(userEntity);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initialized(),
    Result loadInProgress(),
    Result loadSuccess(UserEntity userEntity),
    Result loadFailure(AuthFailure failure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(userEntity);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initialized(SignInAnonymousInitialized value),
    @required Result loadInProgress(SignInAnonymousLoadInProgress value),
    @required Result loadSuccess(SignInAnonymousLoadSuccess value),
    @required Result loadFailure(SignInAnonymousLoadFailure value),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadSuccess(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initialized(SignInAnonymousInitialized value),
    Result loadInProgress(SignInAnonymousLoadInProgress value),
    Result loadSuccess(SignInAnonymousLoadSuccess value),
    Result loadFailure(SignInAnonymousLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadSuccess != null) {
      return loadSuccess(this);
    }
    return orElse();
  }
}

abstract class SignInAnonymousLoadSuccess implements SignInAnonymousState {
  const factory SignInAnonymousLoadSuccess(UserEntity userEntity) =
      _$SignInAnonymousLoadSuccess;

  UserEntity get userEntity;
  $SignInAnonymousLoadSuccessCopyWith<SignInAnonymousLoadSuccess> get copyWith;
}

/// @nodoc
abstract class $SignInAnonymousLoadFailureCopyWith<$Res> {
  factory $SignInAnonymousLoadFailureCopyWith(SignInAnonymousLoadFailure value,
          $Res Function(SignInAnonymousLoadFailure) then) =
      _$SignInAnonymousLoadFailureCopyWithImpl<$Res>;
  $Res call({AuthFailure failure});

  $AuthFailureCopyWith<$Res> get failure;
}

/// @nodoc
class _$SignInAnonymousLoadFailureCopyWithImpl<$Res>
    extends _$SignInAnonymousStateCopyWithImpl<$Res>
    implements $SignInAnonymousLoadFailureCopyWith<$Res> {
  _$SignInAnonymousLoadFailureCopyWithImpl(SignInAnonymousLoadFailure _value,
      $Res Function(SignInAnonymousLoadFailure) _then)
      : super(_value, (v) => _then(v as SignInAnonymousLoadFailure));

  @override
  SignInAnonymousLoadFailure get _value =>
      super._value as SignInAnonymousLoadFailure;

  @override
  $Res call({
    Object failure = freezed,
  }) {
    return _then(SignInAnonymousLoadFailure(
      failure == freezed ? _value.failure : failure as AuthFailure,
    ));
  }

  @override
  $AuthFailureCopyWith<$Res> get failure {
    if (_value.failure == null) {
      return null;
    }
    return $AuthFailureCopyWith<$Res>(_value.failure, (value) {
      return _then(_value.copyWith(failure: value));
    });
  }
}

/// @nodoc
class _$SignInAnonymousLoadFailure implements SignInAnonymousLoadFailure {
  const _$SignInAnonymousLoadFailure(this.failure) : assert(failure != null);

  @override
  final AuthFailure failure;

  @override
  String toString() {
    return 'SignInAnonymousState.loadFailure(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is SignInAnonymousLoadFailure &&
            (identical(other.failure, failure) ||
                const DeepCollectionEquality().equals(other.failure, failure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(failure);

  @override
  $SignInAnonymousLoadFailureCopyWith<SignInAnonymousLoadFailure>
      get copyWith =>
          _$SignInAnonymousLoadFailureCopyWithImpl<SignInAnonymousLoadFailure>(
              this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result initialized(),
    @required Result loadInProgress(),
    @required Result loadSuccess(UserEntity userEntity),
    @required Result loadFailure(AuthFailure failure),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(failure);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result initialized(),
    Result loadInProgress(),
    Result loadSuccess(UserEntity userEntity),
    Result loadFailure(AuthFailure failure),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result initialized(SignInAnonymousInitialized value),
    @required Result loadInProgress(SignInAnonymousLoadInProgress value),
    @required Result loadSuccess(SignInAnonymousLoadSuccess value),
    @required Result loadFailure(SignInAnonymousLoadFailure value),
  }) {
    assert(initialized != null);
    assert(loadInProgress != null);
    assert(loadSuccess != null);
    assert(loadFailure != null);
    return loadFailure(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result initialized(SignInAnonymousInitialized value),
    Result loadInProgress(SignInAnonymousLoadInProgress value),
    Result loadSuccess(SignInAnonymousLoadSuccess value),
    Result loadFailure(SignInAnonymousLoadFailure value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadFailure != null) {
      return loadFailure(this);
    }
    return orElse();
  }
}

abstract class SignInAnonymousLoadFailure implements SignInAnonymousState {
  const factory SignInAnonymousLoadFailure(AuthFailure failure) =
      _$SignInAnonymousLoadFailure;

  AuthFailure get failure;
  $SignInAnonymousLoadFailureCopyWith<SignInAnonymousLoadFailure> get copyWith;
}
